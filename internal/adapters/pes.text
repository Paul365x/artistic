package pes

import (
	"encoding/binary"
	"fmt"
	"image/color"
	"io"
	"os"
)

var fh *os.File = os.Stdout

/*
**
** Header parsing code
**
 */

// Preamble stores the first 12 bytes of a pes file
type Preamble struct {
	Id     string
	Ver    string
	Offset uint32
	count  uint32
}

// Preamble.Parse reads in the first 12 bytes of a pes file into the struct
func (s *Preamble) Parse(bin []byte) {
	s.Id = string(bin[:4])
	s.Ver = string(bin[4:8])
	s.Offset = binary.LittleEndian.Uint32(bin[8:12])
	s.count = 12
}

// Preamble.SizeOf returns the size in bytes - offset into the file of the byte after the preamble. Always 12 bytes
func (p Preamble) SizeOf() uint32 {
	return p.count
}

// Dump writes out this Struct
func (p Preamble) Dump() {
	fmt.Fprintf(fh, "Preamble:\n")
	fmt.Fprintf(fh, "\tId: %s\n", p.Id)
	fmt.Fprintf(fh, "\tVer: %s\n", p.Ver)
	fmt.Fprintf(fh, "\tOffset: %d 0x%X\n", p.Offset, p.Offset)
	fmt.Fprintf(fh, "\tcount: %d 0x%X\n", p.count, p.count)
}

// ColorSub stores the color structure
type ColorSub struct {
	CodeLen  uint8
	Code     []byte
	Color    color.Color
	u1       uint8
	ColType  uint32
	DescLen  uint8
	Desc     string
	BrandLen uint8
	Brand    string
	ChartLen uint8
	Chart    string
	count    uint32
}

// Dump writes out this Struct
func (p ColorSub) Dump() {
	fmt.Fprintf(fh, "\t\tColorSub:\n")
	fmt.Fprintf(fh, "\t\t\tCodeLen: %d 0x%X\n", p.CodeLen, p.CodeLen)
	fmt.Fprintf(fh, "\t\t\tCode: 0x%X\n", p.Code)
	rgba := color.RGBAModel.Convert(p.Color).(color.RGBA)
	fmt.Fprintf(fh, "\t\t\tColor: (%d, %d, %d, %d)\n", rgba.R, rgba.G, rgba.B, rgba.A)
	fmt.Fprintf(fh, "\t\t\tu1: %d 0x%X\n", p.u1, p.u1)
	fmt.Fprintf(fh, "\t\t\tDescLen: %d 0x%X\n", p.DescLen, p.DescLen)
	fmt.Fprintf(fh, "\t\t\tDesc: %s\n", p.Desc)
	fmt.Fprintf(fh, "\t\t\tBrandLen: %d 0x%X\n", p.BrandLen, p.BrandLen)
	fmt.Fprintf(fh, "\t\t\tBrand: %s\n", p.Brand)
	fmt.Fprintf(fh, "\t\t\tChartLen: %d 0x%X\n", p.ChartLen, p.ChartLen)
	fmt.Fprintf(fh, "\t\t\tChart: %s\n", p.Chart)
	fmt.Fprintf(fh, "\t\t\tcount: %d 0x%X\n", p.count, p.count)
}

// parse_color_sub parses in a color structure
func parse_color_sub(bin []byte) (uint32, ColorSub) {
	var col ColorSub
	var count uint32
	count = 0
	col.CodeLen = bin[count]
	count++
	col.Code = bin[count : count+uint32(col.CodeLen)]
	count += uint32(col.CodeLen)
	red := bin[count]
	count++
	green := bin[count]
	count++
	blue := bin[count]
	count++
	col.Color = color.RGBA{red, green, blue, 255}
	col.u1 = bin[count]
	count++
	col.ColType = binary.LittleEndian.Uint32(bin[count : count+4])
	count += 4
	col.DescLen = bin[count]
	count++
	col.Desc = string(bin[count : count+uint32(col.DescLen)])
	count += uint32(col.DescLen)
	col.BrandLen = bin[count]
	count++
	col.Brand = string(bin[count : count+uint32(col.BrandLen)])
	count += uint32(col.BrandLen)
	col.ChartLen = bin[count]
	count++
	col.Chart = string(bin[count : count+uint32(col.ChartLen)])
	count += uint32(col.ChartLen)
	col.count = count
	return count, col
}

// H_1 is version 1 header struct of a pes file
type H_1 struct {
	Hoop      uint16
	EDA       uint16
	Blk_count uint16
	count     uint32
}

// H_1.Parse in the version one header of a pes file
func (h1 *H_1) Parse(bin []byte) {
	h1.Hoop = binary.LittleEndian.Uint16(bin[0:2])
	h1.EDA = binary.LittleEndian.Uint16(bin[2:4])
	h1.Blk_count = binary.LittleEndian.Uint16(bin[4:6])
	h1.count = 6
}

// H_1.SizeOf returns the byte offset into the file of the next byte to read - always 6 bytes
func (h1 H_1) SizeOf() uint32 {
	return h1.count
}

// Dump writes out this Struct
func (p H_1) Dump() {
	fmt.Fprintf(fh, "Header1:\n")
	fmt.Fprintf(fh, "\tHoop: %d\n", p.Hoop)
	fmt.Fprintf(fh, "\tEDA: %d\n", p.EDA)
	fmt.Fprintf(fh, "\tBlk_count: %d 0x%X\n", p.Blk_count, p.Blk_count)
	fmt.Fprintf(fh, "\tcount: %d 0x%X\n", p.count, p.count)
}

// H_2 stores the version 2 header
type H_2 struct {
	HoopW uint16
	HoopH uint16
	Rot   uint16
	unk   []byte
	count uint32
}

// H_2.Parse parses a version 2 header into the struct
func (h2 *H_2) Parse(bin []byte) {
	h2.HoopW = binary.LittleEndian.Uint16(bin[0:2])
	h2.HoopH = binary.LittleEndian.Uint16(bin[2:4])
	h2.Rot = binary.LittleEndian.Uint16(bin[4:6])
	h2.unk = bin[6:24]
	h2.count = 24
}

// H_2.SizeOf returns the offset into the file of the next byte after the header - always 24 bytes
func (h2 H_2) SizeOf() uint32 {
	return h2.count
}

// Dump writes out this Struct
func (p H_2) Dump() {
	fmt.Fprintf(fh, "Header2:\n")
	fmt.Fprintf(fh, "\tHoopW: %d 0x%X\n", p.HoopW, p.HoopW)
	fmt.Fprintf(fh, "\tHoopH: %d 0x%X\n", p.HoopH, p.HoopH)
	fmt.Fprintf(fh, "\tRot: %d 0x%X\n", p.Rot, p.Rot)
	fmt.Fprintf(fh, "\tunk: 0x%X\n", p.unk)
	fmt.Fprintf(fh, "\tcount: %d 0x%X\n", p.count, p.count)
}

// H_25 struct is version 2.5 header. No sample files found so no testing done on it.
type H_25 struct {
	u1    uint32
	Hoop  uint32
	Rot   uint16
	unk   []byte
	Obj   uint16
	count uint32
}

// H_25.Parse parses header version 2.5 - not tested
func (h25 H_25) Parse(bin []byte) {
	h25.u1 = binary.LittleEndian.Uint32(bin[0:4])
	h25.Hoop = binary.LittleEndian.Uint32(bin[4:8])
	h25.Rot = binary.LittleEndian.Uint16(bin[8:10])
	h25.unk = bin[10:26]
	h25.Obj = binary.LittleEndian.Uint16(bin[26:28])
	h25.count = 28
}

// H.25.SizeOf returns offset into the file of the next byte - not tested
func (h25 H_25) SizeOf() uint32 {
	return h25.count
}

// H_3 version three of the header
type H_3 struct {
	u1    uint16
	SubV  uint16
	HoopW uint16
	HoopH uint16
	Rot   uint16
	u2    []byte
	count uint32
}

// H_3.Parse version three header parser
func (h3 *H_3) Parse(bin []byte) {
	h3.u1 = binary.LittleEndian.Uint16(bin[0:2])
	h3.SubV = binary.LittleEndian.Uint16(bin[2:4])
	h3.HoopW = binary.LittleEndian.Uint16(bin[4:6])
	h3.HoopH = binary.LittleEndian.Uint16(bin[6:8])
	h3.Rot = binary.LittleEndian.Uint16(bin[8:10])
	h3.u2 = bin[10:28]
	h3.count = 28
}

// H_3.SizeOf returns the offset into the file of the next byte - always 28 bytes
func (h3 H_3) SizeOf() uint32 {
	return h3.count
}

// Dump writes out this Struct
func (p H_3) Dump() {
	fmt.Fprintf(fh, "Header3:\n")
	fmt.Fprintf(fh, "\tu1: %d 0x%X\n", p.u1, p.u1)
	fmt.Fprintf(fh, "\tSubV: %d 0x%X\n", p.SubV, p.SubV)
	fmt.Fprintf(fh, "\tHoopW: %d 0x%X\n", p.HoopW, p.HoopW)
	fmt.Fprintf(fh, "\tHoopH: %d 0x%X\n", p.HoopH, p.HoopH)
	fmt.Fprintf(fh, "\tRot: %d 0x%X\n", p.Rot, p.Rot)
	fmt.Fprintf(fh, "\tu2: %d 0x%X\n", p.u2, p.u2)
	fmt.Fprintf(fh, "\tcount: %d 0x%X\n", p.count, p.count)
}

// H_4 is version 4 of the header
type H_4 struct {
	u1    uint16
	SubV  uint16
	Desc  *map[string]string
	u2    uint16
	HoopW uint16
	HoopH uint16
	Rot   uint16
	u3    []byte
	count uint32
}

// H_4.Parse is the version 4 header parser
func (h4 *H_4) Parse(bin []byte) {
	h4.u1 = binary.LittleEndian.Uint16(bin[0:2])
	h4.SubV = binary.LittleEndian.Uint16(bin[2:4])
	var count uint32
	count, h4.Desc = parse_desc(bin[4:])
	count += 4 // allow for u1 and SubV
	h4.u2 = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	h4.HoopW = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	h4.HoopH = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	h4.Rot = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	h4.u3 = bin[count : count+22]
	count += 22
	h4.count = count
}

// H_4 SizeOf returns the offset into the file of the byte after this header
func (h4 H_4) SizeOf() uint32 {
	return h4.count
}

// Dump writes out this Struct
func (p H_4) Dump() {
	fmt.Fprintf(fh, "Header4:\n")
	fmt.Fprintf(fh, "\tu1: %d 0x%X\n", p.u1, p.u1)
	fmt.Fprintf(fh, "\tSubV: %d 0x%X\n", p.SubV, p.SubV)
	fmt.Fprintf(fh, "\tDesc: ")
	fmt.Fprintln(fh, p.Desc)
	fmt.Fprintf(fh, "\tu2: %d 0x%X\n", p.u2, p.u2)
	fmt.Fprintf(fh, "\tHoopW: %d 0x%X\n", p.HoopW, p.HoopW)
	fmt.Fprintf(fh, "\tHoopH: %d 0x%X\n", p.HoopH, p.HoopH)
	fmt.Fprintf(fh, "\tRot: %d 0x%X\n", p.Rot, p.Rot)
	fmt.Fprintf(fh, "\tu3: 0x%X\n", p.u3)
	fmt.Fprintf(fh, "\tcount: %d 0x%X\n", p.count, p.count)
}

// parse_desc H_4 and following have a description block. this is the parser for that block
func parse_desc(bin []byte) (uint32, *map[string]string) {
	var len uint8
	var count uint32

	meta := make(map[string]string)
	count = 0
	len = uint8(bin[count])
	count++
	meta["Design"] = string(bin[count : count+uint32(len)])
	count = count + uint32(len)

	len = uint8(bin[count])
	count++
	meta["Category"] = string(bin[count : count+uint32(len)])
	count = count + uint32(len)

	len = uint8(bin[count])
	count++
	meta["Author"] = string(bin[count : count+uint32(len)])
	count = count + uint32(len)

	len = uint8(bin[count])
	count++
	meta["Keywords"] = string(bin[count : count+uint32(len)])
	count = count + uint32(len)

	len = uint8(bin[count])
	count++
	meta["Comments"] = string(bin[count : count+uint32(len)])
	count = count + uint32(len)

	return count, &meta
}

/*
**
** Headers 5 & 6
**
 */

// HP_1 is first section of headers 5 and 6
type HP_1 struct {
	HoopInd uint16
	SubV    uint16
	Desc    *map[string]string
	HoopChg uint16
	count   uint32
}

// HP_1.Parse parses the first section of headers 5 and 6
func (h *HP_1) Parse(bin []byte) {
	h.HoopInd = binary.LittleEndian.Uint16(bin[0:2])
	h.SubV = binary.LittleEndian.Uint16(bin[2:4])
	var count uint32
	count, h.Desc = parse_desc(bin[4:])
	count += 4
	h.HoopChg = binary.LittleEndian.Uint16(bin[count : count+2])
	h.count = count + 2
}

// HP_1.SizeOf returns the offset into the file of the next byte after this section
func (h *HP_1) SizeOf() uint32 {
	return h.count
}

// Dump writes out this Struct
func (h HP_1) Dump() {
	fmt.Fprintf(fh, "\tHoopInd: %d 0x%X\n", h.HoopInd, h.HoopInd)
	fmt.Fprintf(fh, "\tSubV: %d 0x%X\n", h.SubV, h.SubV)
	fmt.Fprintf(fh, "\tDesc: ")
	fmt.Fprintln(fh, h.Desc)
	fmt.Fprintf(fh, "\tHoopChg: %d 0x%X\n", h.HoopChg, h.HoopChg)
}

// HP_2 is second section of headers 5 and 6
type HP_2 struct {
	Hoop  uint32
	Rot   uint16
	count uint32
}

// HP_2.Parse parses the second section of headers 5 and 6
func (h *HP_2) Parse(bin []byte) {
	h.Hoop = binary.LittleEndian.Uint32(bin[0:4])
	h.Rot = binary.LittleEndian.Uint16(bin[4:6])
	h.count = 6
}

// HP_2.SizeOf returns the offset into the file of the next byte after this section
func (h *HP_2) SizeOf() uint32 {
	return h.count
}

// Dump writes out this Struct
func (h HP_2) Dump() {
	fmt.Fprintf(fh, "\tHoop: %d 0x%X\n", h.Hoop, h.Hoop)
	fmt.Fprintf(fh, "\tRot: %d 0x%X\n", h.Rot, h.Rot)
}

// HP_3 is third section of headers 5 and 6
type HP_3 struct {
	BG       uint16
	FG       uint16
	Grid     uint16
	Axes     uint16
	Snap     uint16
	Interv   uint16
	u1       uint16
	OptEntEx uint16
	Imlen    uint8
	Impath   string
	Affline  []byte
	count    uint32
}

// HP_3.Parse reads the third section of headers 5 and 6
func (h *HP_3) Parse(bin []byte) {
	h.BG = binary.LittleEndian.Uint16(bin[0:2])
	h.FG = binary.LittleEndian.Uint16(bin[2:4])
	h.Grid = binary.LittleEndian.Uint16(bin[4:6])
	h.Axes = binary.LittleEndian.Uint16(bin[6:8])
	h.Snap = binary.LittleEndian.Uint16(bin[8:10])
	h.Interv = binary.LittleEndian.Uint16(bin[10:12])
	h.u1 = binary.LittleEndian.Uint16(bin[12:14])
	h.OptEntEx = binary.LittleEndian.Uint16(bin[14:16])
	h.Imlen = bin[16]
	o := h.Imlen + 17
	h.Impath = string(bin[17:o])
	h.Affline = bin[o : o+24]
	h.count = uint32(o) + 24
}

// HP_3 returns the offset into the file after the third section of headers 5 and 6
func (h *HP_3) SizeOf() uint32 {
	return h.count
}

// Dump writes out this Struct
func (h HP_3) Dump() {
	fmt.Fprintf(fh, "\tBackground: %d 0x%X\n", h.BG, h.BG)
	fmt.Fprintf(fh, "\tForeground: %d 0x%X\n", h.FG, h.FG)
	fmt.Fprintf(fh, "\tGrid: %d 0x%X\n", h.Grid, h.Grid)
	fmt.Fprintf(fh, "\tAxes: %d 0x%X\n", h.Axes, h.Axes)
	fmt.Fprintf(fh, "\tSnap: %d 0x%X\n", h.Snap, h.Snap)
	fmt.Fprintf(fh, "\tInterval: %d 0x%X\n", h.Interv, h.Interv)
	fmt.Fprintf(fh, "\tu1: %d 0x%X\n", h.u1, h.u1)
	fmt.Fprintf(fh, "\tOptEntEx: %d 0x%X\n", h.OptEntEx, h.OptEntEx)
	fmt.Fprintf(fh, "\tImg Path Len: %d 0x%X\n", h.Imlen, h.Imlen)
	fmt.Fprintf(fh, "\tImg Path: %s\n", h.Impath)
	fmt.Fprintf(fh, "\tAffline: %X\n", h.Affline)
}

// HP_4 is fourth section of headers 5 and 6
type HP_4 struct {
	FillCount  uint16
	Fill       []byte
	MotCount   uint16
	Motif      []byte
	FeathCount uint16
	Feather    []byte
	ColSects   uint16
	Colors     []ColorSub
	Obj        uint16
	count      uint32
}

// HP_4.Parse reads the fourth section of headers 5 and 6
func (h *HP_4) Parse(bin []byte) {
	end := binary.LittleEndian.Uint16(bin[0:2])
	h.Fill = bin[2 : end+2]
	start := end + 2
	end = binary.LittleEndian.Uint16(bin[start : start+2])
	start += 2
	end += start
	h.Motif = bin[start:end]
	start = end
	end = binary.LittleEndian.Uint16(bin[start : start+2])
	start += 2
	end += start
	h.Feather = bin[start:end]
	start = end
	num := binary.LittleEndian.Uint16(bin[start : start+2])
	h.ColSects = num
	start += 2
	end += start
	for i := 0; i < int(num); i++ {
		count, col := parse_color_sub(bin[start:])
		h.Colors = append(h.Colors, col)
		start += uint16(count)
	}
	h.Obj = binary.LittleEndian.Uint16(bin[start : start+2])
	h.count = uint32(start + 2)
}

// HP_4.SizeOf returns the offset into the file of the byte after the fourth section of headers 5 and 6
func (h *HP_4) SizeOf() uint32 {
	return h.count
}

// Dump writes out this Struct
func (h HP_4) Dump() {
	fmt.Fprintf(fh, "\tFillCount: %d 0x%X\n", h.FillCount, h.FillCount)
	fmt.Fprintf(fh, "\tFill: %X", h.Fill)
	fmt.Fprintf(fh, "\tMotCount: %d 0x%X\n", h.MotCount, h.MotCount)
	fmt.Fprintf(fh, "\tMotif: %X", h.Motif)
	fmt.Fprintf(fh, "\tFeatherCount: %d 0x%X\n", h.FeathCount, h.FeathCount)
	fmt.Fprintf(fh, "\tFeather: %X\n", h.Feather)
	fmt.Fprintf(fh, "\tColorSects: %d 0x%X\n", h.ColSects, h.ColSects)
	for i := 0; i < int(h.ColSects); i++ {
		h.Colors[i].Dump()
	}
	fmt.Fprintf(fh, "\tObjects: %d 0x%X\n", h.Obj, h.Obj)
}

// H_5 version 5 of the header
type H_5 struct {
	HP_1
	HP_2
	HP_3
	HP_4
	count uint32
}

// H_5.Parse parses the version 5 header
func (h *H_5) Parse(bin []byte) {
	count := uint32(0)

	h.HP_1.Parse(bin)
	count += h.HP_1.SizeOf()

	h.HP_2.Parse(bin[count:])
	count += h.HP_2.SizeOf()

	h.HP_3.Parse(bin[count:])
	count += h.HP_3.SizeOf()

	h.HP_4.Parse(bin[count:])
	count += h.HP_4.SizeOf()

	h.count = count
}

// H_5.SizeOf returns the offset into the file of the next byte after this header
func (h H_5) SizeOf() uint32 {
	return h.count
}

// Dump displays this struct
func (h H_5) Dump() {
	fmt.Fprintln(fh, "Header5:")
	h.HP_1.Dump()
	h.HP_2.Dump()
	h.HP_3.Dump()
	h.HP_4.Dump()
	fmt.Fprintf(fh, "\tcount: %d 0x%X\n", h.count, h.count)
}

// H_6 version header
type H_6 struct {
	HP_1
	Cust uint16
	HP_2
	DWidth   uint16
	DHeight  uint16
	DPWidth  uint16
	DPHeight uint16
	u1       uint16
	HP_3
	HP_4
	count uint32
}

// H_6.Parse reads the version 6 header
func (h *H_6) Parse(bin []byte) {
	count := uint32(0)

	h.HP_1.Parse(bin)
	count += h.HP_1.SizeOf()

	h.Cust = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2

	h.HP_2.Parse(bin[count:])
	count += h.HP_2.SizeOf()

	h.DWidth = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	h.DHeight = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	h.DPWidth = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	h.DPHeight = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	h.u1 = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2

	h.HP_3.Parse(bin[count:])
	count += h.HP_3.SizeOf()

	h.HP_4.Parse(bin[count:])
	count += h.HP_4.SizeOf()

	h.count = count
}

// H_6.SizeOf returns the next byte in the file after this header
func (h6 H_6) SizeOf() uint32 {
	return h6.count
}

// Dump displays this struct
func (h H_6) Dump() {
	fmt.Fprintln(fh, "Header6:")
	h.HP_1.Dump()
	fmt.Fprintf(fh, "\tCust: %d 0x%X\n", h.Cust, h.Cust)
	h.HP_2.Dump()
	fmt.Fprintf(fh, "\tDWidth: %d 0x%X\n", h.DWidth, h.DWidth)
	fmt.Fprintf(fh, "\tDHeight: %d 0x%X\n", h.DHeight, h.DHeight)
	fmt.Fprintf(fh, "\tDPWidth: %d 0x%X\n", h.DPWidth, h.DPWidth)
	fmt.Fprintf(fh, "\tDPHeight: %d 0x%X\n", h.DPHeight, h.DPHeight)
	fmt.Fprintf(fh, "\tu1: %d 0x%X\n", h.u1, h.u1)
	h.HP_3.Dump()
	h.HP_4.Dump()
}

// Header stores the pes header in all forms
type Header struct {
	Ver   string
	P     Preamble
	H1    H_1
	H2    H_2
	H25   H_25
	H3    H_3
	H4    H_4
	H5    H_5
	H6    H_6
	count uint32
	tail  uint32
}

// Header.Parse reads in the pes header
func (Hdr *Header) Parse(bin []byte) {
	ver := string(bin[4:8])
	Hdr.Ver = ver
	switch ver {
	case "0001":
		var h_p Preamble
		var h1 H_1
		h_p.Parse(bin)
		count_p := h_p.SizeOf()
		h1.Parse(bin[count_p:])
		Hdr.P = h_p
		Hdr.H1 = h1
		Hdr.count = h1.SizeOf() + h_p.SizeOf()
	case "0020":
		var h_p Preamble
		var h H_2
		h_p.Parse(bin)
		count_p := h_p.SizeOf()
		h.Parse(bin[count_p:])
		Hdr.P = h_p
		Hdr.H2 = h
		Hdr.count = h.SizeOf() + h_p.SizeOf()
	case "0030":
		var h_p Preamble
		var h H_3
		h_p.Parse(bin)
		count_p := h_p.SizeOf()
		h.Parse(bin[count_p:])
		Hdr.P = h_p
		Hdr.H3 = h
		Hdr.count = h.SizeOf() + h_p.SizeOf()
	case "0040":
		var h_p Preamble
		var h H_4
		h_p.Parse(bin)
		count_p := h_p.SizeOf()
		h.Parse(bin[count_p:])
		Hdr.P = h_p
		Hdr.H4 = h
		Hdr.count = h.SizeOf() + h_p.SizeOf()
	case "0050":
		var h_p Preamble
		var h H_5
		h_p.Parse(bin)
		count_p := h_p.SizeOf()
		h.Parse(bin[count_p:])
		count_p += h.SizeOf()
		Hdr.P = h_p
		Hdr.H5 = h
		Hdr.count = h.SizeOf() + h_p.SizeOf()
	case "0060":
		var h_p Preamble
		var h H_6
		h_p.Parse(bin)
		count_p := h_p.SizeOf()
		h.Parse(bin[count_p:])
		count_p += h.SizeOf()
		Hdr.P = h_p
		Hdr.H6 = h
		Hdr.count = h.SizeOf() + h_p.SizeOf()
	}
	Hdr.tail = binary.LittleEndian.Uint32(bin[Hdr.count : Hdr.count+4])
	Hdr.count += 4
}

// Header.SizeOf returns the offset of the next byte after the header
func (h *Header) SizeOf() uint32 {
	return h.count
}

// Dump writes out this Struct
func (h Header) Dump() {
	h.P.Dump()
	switch h.Ver {
	case "0001":
		h.H1.Dump()
	case "0020":
		h.H2.Dump()
	case "0030":
		h.H3.Dump()
	case "0040":
		h.H4.Dump()
	case "0050":
		h.H5.Dump()
	case "0060":
		h.H6.Dump()
	}
	fmt.Fprintf(fh, "\ttail: %x\n", h.tail)
	fmt.Fprintf(fh, "\tcount: %d 0x%X\n", h.count, h.count)
}

/*
**
** Embroidery definition code
**
 */

// CEmbOne is the cembone section
type CEmbOne struct {
	IdLen uint16
	Id    string
	Seg   []byte
	//CSewSegHdr
	count uint32
}

// CEmbOne.Parse reads in a cembone section
func (s *CEmbOne) Parse(bin []byte) {
	s.IdLen = binary.LittleEndian.Uint16(bin[0:2])
	s.Id = string(bin[2 : s.IdLen+2])
	s.count = uint32(s.IdLen) + 2
	//s.Seg.Parse(
	s.Seg = bin[s.count : s.count+64]
	s.count += 64
	// s.Seg.SizeOf()
}

// CEmbOne.SizeOf returns the offset of the byte after this section
func (s *CEmbOne) SizeOf() uint32 {
	return s.count
}

// Dump displays this struct
func (h CEmbOne) Dump() {
	fmt.Fprintln(fh, "CEmbOne:")
	fmt.Fprintf(fh, "\tIdLen: %d 0x%X\n", h.IdLen, h.IdLen)
	fmt.Fprintf(fh, "\tId: %s\n", h.Id)
	fmt.Fprintf(fh, "\tSeg: %X\n", h.Seg)
	// h.Seg.Dump()
	fmt.Fprintf(fh, "\tcount: %d 0x%X\n", h.count, h.count)
}

type StitchCoord struct {
	X     uint16
	Y     uint16
	count uint32
}

func (s *StitchCoord) Parse(bin []byte) {
	count := uint32(0)
	s.X = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	s.Y = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	s.count = count
}

func (s StitchCoord) SizeOf() uint32 {
	return s.count
}

// Dump displays this struct
func (h StitchCoord) Dump() {
	fmt.Fprintln(fh, "\t\t\tStitchCoord:")
	fmt.Fprintf(fh, "\t\t\t\tX: %d 0x%X\n", h.X, h.X)
	fmt.Fprintf(fh, "\t\t\t\tY: %d 0x%X\n", h.Y, h.Y)
	fmt.Fprintf(fh, "\t\t\t\tcount: %d 0x%X\n", h.count, h.count)
}

// StitchList is a coordinate subsection
type StitchList struct {
	StitchType uint16
	ThreadIdx  uint16
	NumCoord   uint16
	Coords     []StitchCoord
	Cont       uint16
	count      uint32
}

// Parse reads binary into the stitchlist struct
func (s *StitchList) Parse(bin []byte) {
	count := uint32(0)
	s.StitchType = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	s.ThreadIdx = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	s.NumCoord = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	for i := 0; i < int(s.NumCoord); i++ {
		var c StitchCoord
		c.Parse(bin[count:])
		s.Coords = append(s.Coords, c)
		count += c.SizeOf()
	}
	s.Cont = binary.LittleEndian.Uint16(bin[count : count+2])
	if s.Cont == 0x8003 {
		count += 2
	} else {
		s.Cont = 0
	}
	s.count = count
}

func (s *StitchList) SizeOf() uint32 {
	return s.count
}

// Dump displays this struct
func (h StitchList) Dump() {
	fmt.Fprintln(fh, "\t\tStitchList:")
	fmt.Fprintf(fh, "\t\t\tStitchType: %d 0x%X\n", h.StitchType, h.StitchType)
	fmt.Fprintf(fh, "\t\t\tThreadIdx: %d 0x%X\n", h.ThreadIdx, h.ThreadIdx)
	fmt.Fprintf(fh, "\t\t\tNumCoord: %d 0x%X\n", h.NumCoord, h.NumCoord)
	for i := 0; i < int(h.NumCoord); i++ {
		h.Coords[i].Dump()
	}
	fmt.Fprintf(fh, "\t\tContinue: %d 0x%X\n", h.Cont, h.Cont)
	fmt.Fprintf(fh, "\t\tcount: %d 0x%X\n", h.count, h.count)
}

type ThrColor struct {
	BlkIdx uint16
	ThrIdx uint16
	count  uint32
}

func (s *ThrColor) Parse(bin []byte) {
	count := uint32(0)
	s.BlkIdx = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	s.ThrIdx = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	s.count = count
}

func (s ThrColor) SizeOf() uint32 {
	return s.count
}

// Dump displays this struct
func (h ThrColor) Dump() {
	fmt.Fprintln(fh, "\t\tThreadColor:")
	fmt.Fprintf(fh, "\t\t\tBlkIdx: %d 0x%X\n", h.BlkIdx, h.BlkIdx)
	fmt.Fprintf(fh, "\t\t\tThreadIdx: %d 0x%X\n", h.ThrIdx, h.ThrIdx)
	fmt.Fprintf(fh, "\t\t\tcount: %d 0x%X\n", h.count, h.count)
}

type ColorList struct {
	NumCol uint16
	Colors []ThrColor
	count  uint32
}

func (c *ColorList) Parse(bin []byte) {
	count := uint32(0)
	num := binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	for i := 0; i < int(num); i++ {
		var t ThrColor
		t.Parse(bin[count:])
		c.Colors = append(c.Colors, t)
		count += t.SizeOf()
	}
	c.NumCol = num
	c.count = count
}

func (c *ColorList) SizeOf() uint32 {
	return c.count
}

// Dump displays this struct
func (h ColorList) Dump() {
	fmt.Fprintln(fh, "\tColorList:")
	fmt.Fprintf(fh, "\t\tNumColor: %d 0x%X\n", h.NumCol, h.NumCol)
	for i := 0; i < int(h.NumCol); i++ {
		h.Colors[i].Dump()
	}
	fmt.Fprintf(fh, "\t\txcount: %d 0x%X\n", h.count, h.count)
}

type SegBlock struct {
	Stitches []StitchList
	Colors   ColorList
	count    uint32
}

func (s *SegBlock) Parse(bin []byte) {
	count := uint32(0)
	var Stitch StitchList
	for {
		Stitch.Parse(bin[count:])
		count += Stitch.SizeOf()
		s.Stitches = append(s.Stitches, Stitch)
		if Stitch.Cont == 0 {
			break
		}
	}
	s.Colors.Parse(bin[s.count:])
	s.count += s.Colors.SizeOf() + count
}

func (s *SegBlock) SizeOf() uint32 {
	return s.count
}

// Dump displays this struct
func (h SegBlock) Dump() {
	fmt.Fprintln(fh, "\tSegBlock:")
	for i := 0; i < len(h.Stitches); i++ {
		h.Stitches[i].Dump()
	}
	h.Colors.Dump()
	fmt.Fprintf(fh, "\t\tcount: %d 0x%X\n", h.count, h.count)
}

// CSewSeg contains the Csewseg blog
// little different order is seg -> [hdr]->[seg]...
type CSewSeg struct {
	IdLen uint16
	Id    string
	Segs  []SegBlock
	Hdrs  []CSewSegHdr
	count uint32
}

func (s *CSewSeg) Parse(bin []byte) {
	count := uint32(0)
	s.IdLen = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	s.Id = string(bin[count : count+uint32(s.IdLen)])
	count += uint32(s.IdLen)
	var seg SegBlock
	var hdr CSewSegHdr
	seg.Parse(bin[count:])
	s.Segs = append(s.Segs, seg)
	count += seg.SizeOf()
	s.Hdrs = append(s.Hdrs, hdr)
	for {
		test := string(bin[count : count+7])
		if test != "CEmbOne" {
			break
		}
		hdr.Parse(bin[count:])
		count += hdr.SizeOf()
		seg.Parse(bin[count:])
		count += seg.SizeOf()
		s.Segs = append(s.Segs, seg)
		s.Hdrs = append(s.Hdrs, hdr)
	}
	s.count = count
}

func (s *CSewSeg) SizeOf() uint32 {
	return s.count
}

// Dump displays this struct
func (h CSewSeg) Dump() {
	fmt.Fprintln(fh, "CSewSeg:")
	fmt.Fprintf(fh, "\tIdLen: %d 0x%X\n", h.IdLen, h.IdLen)
	fmt.Fprintf(fh, "\tId: %s\n", h.Id)
	for i := 0; i < len(h.Segs); i++ {
		if i != 0 {
			h.Hdrs[i].Dump()
		}
		h.Segs[i].Dump()
	}
	fmt.Fprintf(fh, "\tcount: %d 0x%X\n", h.count, h.count)
}

// CSewSegHdr is the CSewSeg Header
type CSewSegHdr struct {
	IdLen    uint16
	Id       string
	Section  []byte
	u1       uint16
	XTrans   int16
	YTrans   int16
	Width    int16
	Height   int16
	u2       uint8
	BlkCount uint16
	count    uint32
}

func (c *CSewSegHdr) Parse(bin []byte) {
	count := uint32(0)
	c.IdLen = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	c.Id = string(bin[count : count+uint32(c.IdLen)])
	count += uint32(c.IdLen)
	c.Section = bin[count : count+40]
	count += 40
	c.u1 = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	c.XTrans = int16(binary.LittleEndian.Uint16(bin[count : count+2]))
	count += 2
	c.YTrans = int16(binary.LittleEndian.Uint16(bin[count : count+2]))
	count += 2
	c.Width = int16(binary.LittleEndian.Uint16(bin[count : count+2]))
	count += 2
	c.Height = int16(binary.LittleEndian.Uint16(bin[count : count+2]))
	count += 2
	c.u2 = bin[count]
	count++
	c.BlkCount = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	c.count = count
}

func (p *CSewSegHdr) SizeOf() uint32 {
	return p.count
}

// Dump displays this struct
func (h CSewSegHdr) Dump() {
	fmt.Fprintln(fh, "\tCSewSegHdr:")
	fmt.Fprintf(fh, "\t\tIdLen: %d 0x%X\n", h.IdLen, h.IdLen)
	fmt.Fprintf(fh, "\t\tId: %s\n", h.Id)
	fmt.Fprintf(fh, "\t\tSection: %X\n", h.Section)
	fmt.Fprintf(fh, "\t\tu1: %d 0x%X\n", h.u1, h.u1)
	fmt.Fprintf(fh, "\t\tXTrans: %d 0x%X\n", h.XTrans, h.XTrans)
	fmt.Fprintf(fh, "\t\tYTrans: %d 0x%X\n", h.YTrans, h.YTrans)
	fmt.Fprintf(fh, "\t\tWidth: %d 0x%X\n", h.Width, h.Width)
	fmt.Fprintf(fh, "\t\tHeight: %d 0x%X\n", h.Height, h.Height)
	fmt.Fprintf(fh, "\t\tu2: %d 0x%X\n", h.u2, h.u2)
	fmt.Fprintf(fh, "\t\tBlkCount: %d 0x%X\n", h.BlkCount, h.BlkCount)
	fmt.Fprintf(fh, "\t\tcount: %d 0x%X\n", h.count, h.count)
}

/*
**
** Block Shapes
**
 */

type BlockDesc struct {
	Section     []byte
	IsOpen      int16
	UseOutline  int16
	OutStitch   int16
	OutColor    int16
	ZZWidth     int16
	ZZDens      int16
	OutRunPtch  int16
	RunStiTime  int16
	TripStitch  int16
	UseOutUnder int16
	SharpCorner int16
	Mot         []Motif
	EVStitch    int16
	EVTWidth    int16
	EVHeight    int16
	EVPWidth    int16
	EVRTime     int16
	EVSTime     int16
	EVArr       int16
	UseFill     int16
	FillType    int16
	Density     int16
	UseGrad     int16
}

// Struct for the line shape
type CEmbLine struct {
	IdLen   uint16
	Id      string
	Desc    []byte
	u1      uint16
	VertLen uint16
	Vertexs []byte
	count   uint32
}

func (c *CEmbLine) Parse(bin []byte) {
	count := uint32(0)
	c.IdLen = binary.LittleEndian.Uint16(bin[count : count+2])
	count += 2
	c.Id = string(bin[count : count+uint32(c.IdLen)])
}

type Pes struct {
	Hdr  Header
	CE   CEmbOne
	CS   CSewSeg
	Line CEmbLine
}

func (p Pes) Dump() {
	p.Hdr.Dump()
	p.CE.Dump()
	p.CS.Dump()
	count := p.Hdr.SizeOf() + p.CE.SizeOf() + p.CS.SizeOf()
	fmt.Fprintf(fh, "\tcount: %d 0x%X\n", count, count)
}

func read_pes(file string) {

	// get the actual file contents
	reader, err := os.Open(file)
	if err != nil {
		panic(err)
	}
	bin, err := io.ReadAll(reader)
	if err != nil {
		panic(err)
	}
	reader.Close()

	var pes Pes

	pes.Hdr.Parse(bin)

	count := pes.Hdr.SizeOf()

	length := binary.LittleEndian.Uint16(bin[count : count+2])
	BlkId := string(bin[count+2 : count+2+uint32(length)])
	switch BlkId {
	case "CEmbOne":
		pes.CE.Parse(bin[count:])
		count += pes.CE.SizeOf()
	case "CSewSeg":
		pes.CS.Parse(bin[count:])
		count += pes.CS.SizeOf()
	case "CEmbLine":
		pes.Line.Parse(bin[count:])
	case "CEmbCirc":
		break
	default:
		break

	}

	pes.Dump()

}

func main() {
	read_pes("circ1.pes")
}
