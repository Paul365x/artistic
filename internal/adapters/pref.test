package main

import (
	"image/color"
	"log"
	"math"
	"time"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/theme"
	"fyne.io/fyne/v2/widget"
	//"fyne.io/fyne/v2/animation"
	//"fyne.io/fyne/v2/theme"
)

type ProgressLayout struct {
	animate *fyne.Animation  // ptr to animation object
	current int              // first index into lines matrix
	face    *canvas.Circle   // background circle
	lines   [][]*canvas.Line // matrix of lines phases by steps
	origin  *canvas.Line     // not sure I need this
	steps   int              // number of steps/lines in a phases

	Border_width float32       // width of border circle for face
	Degrees      int           // which hsl color we are up to
	Phases       float32       // number of segments/colors on circle
	Radius       float32       // radius of face
	Timeout      time.Duration // time to run the animation before timing out
}

var Layout ProgressLayout = ProgressLayout{
	current:      0,
	Border_width: 2.0,
	Degrees:      0,
	Phases:       180,
	Radius:       50.0,
	Timeout:      5 * time.Second,
}

func (l *ProgressLayout) calc_pos(degrees, nibbles int) fyne.Position {
	offset := float64(l.steps*degrees + nibbles)
	length := l.Radius - l.Border_width
	x := l.Radius + (length * float32(math.Cos(offset)))
	y := l.Radius + (-length * float32(math.Sin(offset)))
	return fyne.NewPos(x, y)
}

// SetupProgress initialises the progress popup widget
func (l *ProgressLayout) SetupProgress(w fyne.Window) *widget.PopUp {
	l.steps = int(math.Round(float64((2.0 * math.Pi * l.Radius) / l.Phases))) // this gives us a step size of 180th of circle
	l.steps += 1                                                              // overcome rounding errors
	l.face = canvas.NewCircle(color.White)
	l.face.StrokeColor = color.Black
	l.face.StrokeWidth = l.Border_width
	cont := container.NewWithoutLayout(
		l.face,
	)
	l.lines = make([][]*canvas.Line, int(l.Phases))
	for i := range 180 {
		l.lines[i] = make([]*canvas.Line, l.steps)
		for j := range l.steps {
			l.lines[i][j] = canvas.NewLine(color.White)
			l.lines[i][j].Position1 = fyne.NewPos(l.Radius, l.Radius)
			l.lines[i][j].Position2 = l.calc_pos(i, j)
			cont.Add(l.lines[i][j])
		}
	}
	log.Println(l.steps)
	line := canvas.NewLine(color.Black)
	line.StrokeColor = color.Black
	line.StrokeWidth = 1
	l.origin = line

	return widget.NewPopUp(cont, w.Canvas())
}

func (l *ProgressLayout) RunProgress(w fyne.Window, p *widget.PopUp) {
	s := w.Canvas().Size()
	tly := (s.Height / 2) - l.Radius
	tlx := (s.Width / 2) - l.Radius
	loc := p.Position().AddXY(tlx, tly)
	l.origin.Position1 = fyne.NewPos(0, 0)
	l.origin.Position2 = fyne.NewPos(l.Radius, l.Radius)
	l.face.Position1 = fyne.NewPos(0, 0)
	l.face.Position2 = fyne.NewPos(l.Radius*2, l.Radius*2)

	p.Resize(fyne.NewSize(l.Radius*2, l.Radius*2))
	p.Move(loc)
	p.Show()
	l.animate = fyne.NewAnimation(l.Timeout, func(err float32) {
		if err == 1.0 {
			log.Println("out of time")
			l.animate.Stop()
			p.Hide()
		}
		for s := range l.steps {
			l.lines[l.current][s].StrokeColor = color.White
			l.lines[l.current][s].Refresh()
		}
		l.current++
		if l.current >= int(l.Phases) {
			l.current = 0
		}
		for s := range l.steps {
			l.lines[l.current][s].StrokeColor = color.Black
			l.lines[l.current][s].Refresh()
		}
	})
	l.animate.Start()
}

func main() {

	myApp := app.New()
	myWindow := myApp.NewWindow("Button Widget")
	myApp.Settings().SetTheme(theme.LightTheme())
	myWindow.Resize(fyne.NewSize(700, 700))
	c := canvas.NewCircle(color.White)
	c.StrokeColor = color.Black
	c.StrokeWidth = 10
	c.Resize(fyne.NewSize(50.0, 50.0))
	cont := container.NewBorder(
		nil, nil, nil, nil,
		c,
	)
	progress := Layout.SetupProgress(myWindow)
	buttons := container.NewCenter(
		widget.NewButton("pop", func() {
			Layout.RunProgress(myWindow, progress)

		}), /*
			widget.NewButton("unpop", func() {
				log.Println("unpop")
				progress.Hide()
			}),*/
	)
	content := container.NewBorder(
		buttons,
		nil, nil, nil, cont,
	)

	//content := widget.NewButtonWithIcon("Home", theme.HomeIcon(), func() {
	//	log.Println("tapped home")
	//})

	myWindow.SetContent(content)
	myWindow.ShowAndRun()
}
